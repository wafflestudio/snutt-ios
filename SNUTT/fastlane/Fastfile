# Disable automatic documentation generation (README.md)
ENV["FASTLANE_SKIP_DOCS"] = "1"

# Constants
XCODEPROJ_PATH = "SNUTT.xcodeproj"
BASE_XCCONFIG_PATH = "XCConfigs/Base.xcconfig"
BUNDLE_ID_PROD = "com.wafflestudio.snutt"
BUNDLE_ID_DEV = "com.wafflestudio.snutt.dev"
BUNDLE_ID_PROD_WIDGET = "#{BUNDLE_ID_PROD}.widget"
BUNDLE_ID_DEV_WIDGET = "#{BUNDLE_ID_DEV}.widget"

default_platform(:ios)

platform :ios do
  desc "Check if version in xcconfig matches the provided version"
  lane :check_version do |options|
    tag_version = options[:version]
    current_version = get_xcconfig_value(
      path: BASE_XCCONFIG_PATH,
      name: "MARKETING_VERSION"
    )

    UI.message("Current version in xcconfig: #{current_version}")
    UI.message("Tag version: #{tag_version}")

    if current_version == tag_version
      UI.success("Version matches!")
      next { matches: true }
    else
      UI.important("Version mismatch detected")
      next { matches: false }
    end
  end

  desc "Update version in #{BASE_XCCONFIG_PATH}"
  lane :update_version do |options|
    new_version = options[:version]

    # Validate version format
    unless new_version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Invalid version format: #{new_version}. Must be X.Y.Z (e.g., 4.0.0)")
    end

    # Update MARKETING_VERSION
    set_xcconfig_value(
      path: BASE_XCCONFIG_PATH,
      name: "MARKETING_VERSION",
      value: new_version
    )

    UI.success("Updated MARKETING_VERSION to #{new_version} in #{BASE_XCCONFIG_PATH}")
  end

  desc "Register a new device and regenerate development provisioning profiles"
  lane :add_device do
    # Prompt for device name and UDID
    device_name = UI.input("Enter device name (e.g., 'John's iPhone'): ")
    device_udid = UI.input("Enter device UDID: ")

    # Register device with Apple Developer Portal
    register_devices(
      devices: {
        device_name => device_udid
      }
    )

    UI.success("Device '#{device_name}' registered successfully!")

    # Regenerate development provisioning profiles to include the new device
    UI.message("Regenerating development provisioning profiles...")
    match(
      type: "development",
      readonly: false,
      force_for_new_devices: true
    )

    UI.success("âœ… Device registered and provisioning profiles updated!")
    UI.important("Please run 'just generate' to apply the updated provisioning profiles.")
  end

  desc "Sync development certificates and profiles for local development"
  lane :sync_dev_certificates do
    # Sync development certificates (readonly for team members)
    # app_identifier and team_id are inherited from Matchfile and Appfile
    match(
      type: "development",
      readonly: true
    )

    # Update code signing for Dev configuration
    update_all_code_signing_settings(
      type: "development",
      app_identifier: BUNDLE_ID_DEV,
      configuration: "Dev"
    )

    # Update code signing for Prod configuration
    update_all_code_signing_settings(
      type: "development",
      app_identifier: BUNDLE_ID_PROD,
      configuration: "Prod"
    )

    UI.success("âœ… Development certificates synced and code signing configured!")
  end

  desc "[Requires Permissions] Sync production (App Store) certificates and profiles"
  lane :sync_prod_certificates do
    # Sync production certificates (readonly: false to allow updates)
    # app_identifier and team_id are inherited from Matchfile and Appfile
    UI.important("Note: This command requires admin permissions to modify certificates.")
    match(
      type: "appstore",
      readonly: false
    )
  end

  desc "Deploy to TestFlight or App Store"
  lane :deploy do |options|
    scheme = options[:scheme]
    configuration = options[:configuration]
    app_identifier = options[:app_identifier]
    deploy_target = options[:deploy_target] # "testflight" or "appstore"
    add_badge = options[:add_badge] || false
    git_tag_name = ENV["GIT_TAG_NAME"] || last_git_tag

    # Get marketing version from xcconfig
    marketing_version = get_xcconfig_value(
      path: BASE_XCCONFIG_PATH,
      name: "MARKETING_VERSION"
    )

    begin
      # Get API key for App Store Connect
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_KEY_ISSUER"],
        key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"]
      )

      # Setup CI environment
      setup_ci if ENV["CI"]

      # Sync certificates and provisioning profiles using Match
      widget_bundle_id = "#{app_identifier}.widget"
      match(
        type: "appstore",
        app_identifier: [app_identifier, widget_bundle_id],
        readonly: is_ci
      )

      # Get the latest build number from App Store Connect for this version
      latest_build_number = latest_testflight_build_number(
        app_identifier: app_identifier,
        api_key: api_key,
        version: marketing_version
      )

      new_build_number = latest_build_number + 1
      UI.message("Latest build number for version #{marketing_version}: #{latest_build_number}")
      UI.message("New build number: #{new_build_number}")

      # Update build number in Base.xcconfig
      set_xcconfig_value(
        path: BASE_XCCONFIG_PATH,
        name: "CURRENT_PROJECT_VERSION",
        value: new_build_number.to_s
      )

      # Install dependencies and generate Xcode project using Tuist
      UI.message("Installing dependencies and generating Xcode project with Tuist...")
      sh("cd .. && mise exec -- tuist install && mise exec -- tuist generate --no-open")

      # Update code signing settings after syncing certificates
      update_all_code_signing_settings(
        type: "appstore",
        app_identifier: app_identifier,
        configuration: configuration
      )

      # Add beta badge if requested (for dev builds)
      if add_badge
        UI.message("Adding beta badge to app icon...")
        add_badge(dark: true)
      end

      # Build the app
      build_app(
        workspace: "SNUTT.xcworkspace",
        scheme: scheme,
        configuration: configuration,
        export_method: "app-store",
      )

      # Upload to App Store Connect
      if deploy_target == "appstore"
        # Get release notes from environment (extracted by GitHub Actions)
        release_notes = ENV["RELEASE_NOTES"]

        # Validate release notes are not empty
        if release_notes.nil? || release_notes.strip.empty?
          UI.user_error!("Release notes are empty. Please add release notes to the GitHub Release before deploying to App Store.")
        end

        upload_to_app_store(
          api_key: api_key,
          skip_screenshots: true,
          skip_metadata: true,
          precheck_include_in_app_purchases: false,
          submit_for_review: true,
          release_notes: {
            'default' => release_notes,
            'ko' => release_notes
          },
          submission_information: {
            add_id_info_uses_idfa: false,
            export_compliance_uses_encryption: false
          }
        )
      else
        upload_to_testflight(
          api_key: api_key,
          skip_waiting_for_build_processing: true
        )
      end

      # Notify success
      UI.success("Successfully deployed #{scheme} (build #{new_build_number}) to #{deploy_target}!")

      # Send success notification to Slack
      send_slack_notification(
        success: true,
        deploy_target: deploy_target,
        configuration: configuration,
        marketing_version: marketing_version,
        build_number: new_build_number,
        git_tag_name: git_tag_name
      )
    rescue => exception
      # Send failure notification to Slack
      send_slack_notification(
        success: false,
        deploy_target: deploy_target,
        configuration: configuration,
        marketing_version: marketing_version,
        build_number: nil,
        git_tag_name: git_tag_name,
        error_message: exception.message
      )
      raise exception
    end
  end

  desc "Deploy Dev build to TestFlight"
  lane :deploy_dev_testflight do
    deploy(
      scheme: "SNUTT Dev",
      configuration: "Dev",
      app_identifier: BUNDLE_ID_DEV,
      deploy_target: "testflight",
      add_badge: true
    )
  end

  desc "Deploy Prod build to TestFlight"
  lane :deploy_prod_testflight do
    deploy(
      scheme: "SNUTT Prod",
      configuration: "Prod",
      app_identifier: BUNDLE_ID_PROD,
      deploy_target: "testflight"
    )
  end

  desc "Deploy Prod build to App Store"
  lane :deploy_prod_appstore do
    deploy(
      scheme: "SNUTT Prod",
      configuration: "Prod",
      app_identifier: BUNDLE_ID_PROD,
      deploy_target: "appstore"
    )
  end

  error do |lane, exception, options|
    UI.error("Error in lane #{lane}: #{exception.message}")
  end

  # Helper function to send Slack notifications
  def send_slack_notification(success:, deploy_target:, configuration:, marketing_version:, build_number:, git_tag_name:, error_message: nil)
    slack_webhook = ENV["SLACK_WEBHOOK"]
    return if slack_webhook.nil? || slack_webhook.empty?

    message = success ?
      "iOS app successfully uploaded to #{deploy_target.capitalize} ðŸŽ‰" :
      "iOS deployment to #{deploy_target.capitalize} failed ðŸ˜¢"

    fields = [
      {
        title: "Target",
        value: deploy_target.capitalize,
        short: true
      },
      {
        title: "Environment",
        value: configuration,
        short: true
      },
      {
        title: "Version",
        value: marketing_version,
        short: true
      }
    ]

    if success
      fields << {
        title: "Build Number",
        value: build_number.to_s,
        short: true
      }
    end

    fields << {
      title: "Tag",
      value: git_tag_name,
      short: false
    }

    if error_message
      fields << {
        title: "Error",
        value: error_message,
        short: false
      }
    end

    slack(
      message: message,
      channel: "#team-snutt-deploy",
      slack_url: slack_webhook,
      success: success,
      attachment_properties: {
        fields: fields
      },
      default_payloads: [:git_author, :last_git_commit]
    )
  end

  # Helper function to update code signing settings for both app and widget
  def update_all_code_signing_settings(type:, app_identifier:, configuration:)
    widget_bundle_id = "#{app_identifier}.widget"

    # Determine code sign identity based on type
    code_sign_identity = type == "development" ? "iPhone Developer" : "iPhone Distribution"

    # Update code signing for main app
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTT"],
      build_configurations: configuration,
      bundle_identifier: app_identifier,
      code_sign_identity: code_sign_identity,
      profile_name: ENV["sigh_#{app_identifier}_#{type}_profile-name"]
    )

    # Update code signing for widget extension
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTTWidgetExtension"],
      build_configurations: configuration,
      bundle_identifier: widget_bundle_id,
      code_sign_identity: code_sign_identity,
      profile_name: ENV["sigh_#{widget_bundle_id}_#{type}_profile-name"]
    )
  end
end
