# Disable automatic documentation generation (README.md)
ENV["FASTLANE_SKIP_DOCS"] = "1"

# ============================================================================
# Configuration Classes
# ============================================================================

# AppConfiguration - Represents dev/prod environments
class AppConfiguration
  attr_reader :type

  def initialize(type)
    @type = type
  end

  DEV = new(:dev)
  PROD = new(:prod)

  # Computed properties (like Swift)
  def scheme
    case type
    when :dev then "SNUTT Dev"
    when :prod then "SNUTT Prod"
    end
  end

  def configuration
    type.to_s.capitalize  # "Dev" or "Prod"
  end

  def bundle_id
    case type
    when :dev then "com.wafflestudio.snutt.dev"
    when :prod then "com.wafflestudio.snutt"
    end
  end

  def widget_bundle_id
    "#{bundle_id}.widget"
  end

  def all_bundle_ids
    [bundle_id, widget_bundle_id]
  end

  def openapi_env
    type.to_s  # "dev" or "prod"
  end

  def add_badge?
    type == :dev
  end

  def to_s
    configuration
  end
end

# UploadTarget - Represents testflight/appstore
class UploadTarget
  attr_reader :type

  def initialize(type)
    @type = type
  end

  TESTFLIGHT = new(:testflight)
  APPSTORE = new(:appstore)

  def to_s
    type.to_s
  end

  def display_name
    type.to_s.capitalize
  end

  def testflight?
    type == :testflight
  end

  def appstore?
    type == :appstore
  end
end

# CodeSigningType - Represents development/distribution code signing
class CodeSigningType
  attr_reader :type, :identity

  def initialize(type, identity)
    @type = type
    @identity = identity
  end

  DEVELOPMENT = new(:development, "iPhone Developer")
  DISTRIBUTION = new(:distribution, "iPhone Distribution")

  def to_s
    type.to_s
  end

  def match_type
    case type
    when :development then "development"
    when :distribution then "appstore"
    end
  end
end

# ============================================================================
# Constants Module
# ============================================================================

module Constants
  # File paths
  XCODEPROJ_PATH = "SNUTT.xcodeproj"
  WORKSPACE_PATH = "SNUTT.xcworkspace"
  BASE_XCCONFIG_PATH = "XCConfigs/Base.xcconfig"

  # Version keys
  MARKETING_VERSION_KEY = "MARKETING_VERSION"
  BUILD_NUMBER_KEY = "CURRENT_PROJECT_VERSION"

  # Xcode targets
  module Targets
    MAIN_APP = "SNUTT"
    WIDGET_EXTENSION = "SNUTTWidgetExtension"
  end

  # Slack
  module Slack
    CHANNEL = "#team-snutt-deploy"
  end

  # Export method
  EXPORT_METHOD_APPSTORE = "app-store"
end

default_platform(:ios)

platform :ios do
  desc "Check if version in xcconfig matches the provided version"
  lane :check_version do |options|
    tag_version = options[:version]
    current_version = get_xcconfig_value(
      path: Constants::BASE_XCCONFIG_PATH,
      name: Constants::MARKETING_VERSION_KEY
    )

    UI.message("Current version in xcconfig: #{current_version}")
    UI.message("Tag version: #{tag_version}")

    if current_version == tag_version
      UI.success("Version matches!")
      next { matches: true }
    else
      UI.important("Version mismatch detected")
      next { matches: false }
    end
  end

  desc "Update version in #{Constants::BASE_XCCONFIG_PATH}"
  lane :update_version do |options|
    new_version = options[:version]

    unless new_version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Invalid version format: #{new_version}. Must be X.Y.Z (e.g., 4.0.0)")
    end

    set_xcconfig_value(
      path: Constants::BASE_XCCONFIG_PATH,
      name: Constants::MARKETING_VERSION_KEY,
      value: new_version
    )

    UI.success("Updated #{Constants::MARKETING_VERSION_KEY} to #{new_version} in #{Constants::BASE_XCCONFIG_PATH}")
  end

  desc "Register a new device and regenerate development provisioning profiles"
  lane :add_device do
    device_name = UI.input("Enter device name (e.g., 'John's iPhone'): ")
    device_udid = UI.input("Enter device UDID: ")

    register_devices(
      devices: {
        device_name => device_udid
      }
    )

    UI.success("Device '#{device_name}' registered successfully!")

    UI.message("Regenerating development provisioning profiles")
    match(
      type: CodeSigningType::DEVELOPMENT.match_type,
      readonly: false,
      force_for_new_devices: true
    )

    UI.success("Device registered and provisioning profiles updated!")
    UI.important("Please run 'just generate' to apply the updated provisioning profiles.")
  end

  desc "Sync development certificates and profiles for local development"
  lane :sync_dev_certificates do
    UI.message("Syncing development certificates for all bundle identifiers")

    all_bundle_ids = [
      AppConfiguration::DEV.all_bundle_ids,
      AppConfiguration::PROD.all_bundle_ids
    ].flatten

    match(
      type: CodeSigningType::DEVELOPMENT.match_type,
      app_identifier: all_bundle_ids,
      readonly: true
    )

    update_all_code_signing_settings(
      signing_type: CodeSigningType::DEVELOPMENT,
      app_config: AppConfiguration::DEV
    )

    update_all_code_signing_settings(
      signing_type: CodeSigningType::DEVELOPMENT,
      app_config: AppConfiguration::PROD
    )

    UI.success("Development certificates synced and code signing configured!")
  end

  desc "[Requires Permissions] Sync production (App Store) certificates and profiles"
  lane :sync_prod_certificates do
    UI.important("Note: This requires admin permissions to modify certificates")

    all_bundle_ids = [
      AppConfiguration::DEV.all_bundle_ids,
      AppConfiguration::PROD.all_bundle_ids
    ].flatten

    match(
      type: CodeSigningType::DISTRIBUTION.match_type,
      app_identifier: all_bundle_ids,
      readonly: false
    )
  end

  # ============================================================================
  # Deploy Lanes
  # ============================================================================

  desc "Deploy Dev build to TestFlight"
  lane :deploy_dev_testflight do
    deploy_app(AppConfiguration::DEV, UploadTarget::TESTFLIGHT)
  end

  desc "Deploy Prod build to TestFlight"
  lane :deploy_prod_testflight do
    deploy_app(AppConfiguration::PROD, UploadTarget::TESTFLIGHT)
  end

  desc "Deploy Prod build to App Store"
  lane :deploy_prod_appstore do
    deploy_app(AppConfiguration::PROD, UploadTarget::APPSTORE)
  end

  # ============================================================================
  # Helper Methods
  # ============================================================================

  def deploy_app(app_config, upload_target)
    git_tag_name = ENV["GIT_TAG_NAME"] || last_git_tag
    marketing_version = get_xcconfig_value(
      path: Constants::BASE_XCCONFIG_PATH,
      name: Constants::MARKETING_VERSION_KEY
    )

    begin
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_KEY_ISSUER"],
        key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"]
      )
      setup_ci if ENV["CI"]

      UI.message("Syncing certificates and provisioning profiles for #{app_config}")
      UI.important("App: #{app_config.bundle_id}, Widget: #{app_config.widget_bundle_id}")
      match(
        type: CodeSigningType::DISTRIBUTION.match_type,
        app_identifier: app_config.all_bundle_ids,
        readonly: is_ci
      )

      build_number = increment_build_number(app_config, api_key, marketing_version)
      generate_project_with_dependencies(app_config)
      update_all_code_signing_settings(
        signing_type: CodeSigningType::DISTRIBUTION,
        app_config: app_config
      )
      add_beta_badge_if_needed(app_config)

      UI.message("Building app: #{app_config.scheme}")
      build_app(
        workspace: Constants::WORKSPACE_PATH,
        scheme: app_config.scheme,
        configuration: app_config.configuration,
        export_method: Constants::EXPORT_METHOD_APPSTORE
      )

      upload_build(app_config, upload_target, api_key, marketing_version, build_number)

      UI.success("Successfully deployed #{app_config.scheme} (build #{build_number}) to #{upload_target.display_name}!")
      send_slack_notification(
        success: true,
        config: app_config,
        target: upload_target,
        version: marketing_version,
        build: build_number,
        tag: git_tag_name
      )
    rescue => exception
      send_slack_notification(
        success: false,
        config: app_config,
        target: upload_target,
        version: marketing_version,
        tag: git_tag_name,
        error: exception.message
      )
      raise exception
    end
  end

  def increment_build_number(app_config, api_key, marketing_version)
    UI.message("Querying latest build number from App Store Connect")
    UI.important("App: #{app_config.bundle_id}, Version: #{marketing_version}")

    latest = latest_testflight_build_number(
      app_identifier: app_config.bundle_id,
      api_key: api_key,
      version: marketing_version
    )

    new_build = latest + 1
    UI.message("Latest build: #{latest}, New build: #{new_build}")

    set_xcconfig_value(
      path: Constants::BASE_XCCONFIG_PATH,
      name: Constants::BUILD_NUMBER_KEY,
      value: new_build.to_s
    )

    new_build
  end

  def generate_project_with_dependencies(app_config)
    UI.message("Generating OpenAPI client for #{app_config.openapi_env} environment")
    sh("cd .. && just openapi-#{app_config.openapi_env}")

    UI.message("Installing dependencies and generating Xcode project with Tuist")
    sh("cd .. && mise exec -- tuist install && mise exec -- tuist generate --no-open")
  end

  def add_beta_badge_if_needed(app_config)
    return unless app_config.add_badge?

    UI.message("Adding beta badge to app icon")
    add_badge(dark: true)
  end

  def upload_build(app_config, upload_target, api_key, marketing_version, build_number)
    UI.message("Uploading build to #{upload_target.display_name}")
    UI.important("App: #{app_config.bundle_id}, Version: #{marketing_version}, Build: #{build_number}")

    if upload_target.appstore?
      release_notes = ENV["RELEASE_NOTES"]

      if release_notes.nil? || release_notes.strip.empty?
        UI.user_error!("Release notes are empty. Add notes to GitHub Release before deploying.")
      end

      upload_to_app_store(
        api_key: api_key,
        app_identifier: app_config.bundle_id,
        app_version: marketing_version,
        build_number: build_number.to_s,
        skip_screenshots: true,
        skip_metadata: true,
        precheck_include_in_app_purchases: false,
        submit_for_review: true,
        release_notes: {
          'default' => release_notes,
          'ko' => release_notes
        },
        submission_information: {
          add_id_info_uses_idfa: false,
          export_compliance_uses_encryption: false
        }
      )
    else
      upload_to_testflight(
        api_key: api_key,
        app_identifier: app_config.bundle_id,
        app_version: marketing_version,
        build_number: build_number.to_s,
        skip_waiting_for_build_processing: true
      )
    end
  end

  error do |lane, exception, options|
    UI.error("Error in lane #{lane}: #{exception.message}")
  end

  def send_slack_notification(success:, config:, target:, version:, tag:, build: nil, error: nil)
    webhook = ENV["SLACK_WEBHOOK"]
    return if webhook.nil? || webhook.empty?

    message = success ?
      "iOS app successfully uploaded to #{target.display_name} ðŸŽ‰" :
      "iOS deployment to #{target.display_name} failed ðŸ˜¢"

    fields = build_slack_fields(config, target, version, build, tag, error)

    slack(
      message: message,
      channel: Constants::Slack::CHANNEL,
      slack_url: webhook,
      success: success,
      attachment_properties: { fields: fields },
      default_payloads: [:git_author, :last_git_commit]
    )
  end

  def build_slack_fields(config, target, version, build, tag, error)
    fields = [
      { title: "Target", value: target.display_name, short: true },
      { title: "Environment", value: config.to_s, short: true },
      { title: "Version", value: version, short: true }
    ]

    fields << { title: "Build Number", value: build.to_s, short: true } if build
    fields << { title: "Tag", value: tag, short: false }
    fields << { title: "Error", value: error, short: false } if error

    fields
  end

  def update_all_code_signing_settings(signing_type:, app_config:)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: Constants::XCODEPROJ_PATH,
      targets: [Constants::Targets::MAIN_APP],
      build_configurations: app_config.configuration,
      bundle_identifier: app_config.bundle_id,
      code_sign_identity: signing_type.identity,
      profile_name: ENV["sigh_#{app_config.bundle_id}_#{signing_type.match_type}_profile-name"]
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      path: Constants::XCODEPROJ_PATH,
      targets: [Constants::Targets::WIDGET_EXTENSION],
      build_configurations: app_config.configuration,
      bundle_identifier: app_config.widget_bundle_id,
      code_sign_identity: signing_type.identity,
      profile_name: ENV["sigh_#{app_config.widget_bundle_id}_#{signing_type.match_type}_profile-name"]
    )
  end
end
