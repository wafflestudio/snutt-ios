# Disable automatic documentation generation (README.md)
ENV["FASTLANE_SKIP_DOCS"] = "1"

# Constants
XCODEPROJ_PATH = "../SNUTT.xcodeproj"
BUNDLE_ID_PROD = "com.wafflestudio.snutt"
BUNDLE_ID_DEV = "com.wafflestudio.snutt.dev"
BUNDLE_ID_PROD_WIDGET = "#{BUNDLE_ID_PROD}.widget"
BUNDLE_ID_DEV_WIDGET = "#{BUNDLE_ID_DEV}.widget"

default_platform(:ios)

platform :ios do
  desc "Check if version in xcconfig matches the provided version"
  lane :check_version do |options|
    tag_version = options[:version]
    current_version = get_xcconfig_value(
      path: "XCConfigs/Base.xcconfig",
      name: "MARKETING_VERSION"
    )

    UI.message("Current version in xcconfig: #{current_version}")
    UI.message("Tag version: #{tag_version}")

    if current_version == tag_version
      UI.success("Version matches!")
      next { matches: true }
    else
      UI.important("Version mismatch detected")
      next { matches: false }
    end
  end

  desc "Update version in XCConfigs/Base.xcconfig"
  lane :update_version do |options|
    new_version = options[:version]

    # Validate version format
    unless new_version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Invalid version format: #{new_version}. Must be X.Y.Z (e.g., 4.0.0)")
    end

    # Update MARKETING_VERSION
    set_xcconfig_value(
      path: "XCConfigs/Base.xcconfig",
      name: "MARKETING_VERSION",
      value: new_version
    )

    UI.success("Updated MARKETING_VERSION to #{new_version} in XCConfigs/Base.xcconfig")
  end

  desc "Register a new device and regenerate development provisioning profiles"
  lane :add_device do
    # Prompt for device name and UDID
    device_name = UI.input("Enter device name (e.g., 'John's iPhone'): ")
    device_udid = UI.input("Enter device UDID: ")

    # Register device with Apple Developer Portal
    register_devices(
      devices: {
        device_name => device_udid
      }
    )

    UI.success("Device '#{device_name}' registered successfully!")

    # Regenerate development provisioning profiles to include the new device
    UI.message("Regenerating development provisioning profiles...")
    match(
      type: "development",
      readonly: false,
      force_for_new_devices: true
    )

    UI.success("âœ… Device registered and provisioning profiles updated!")
    UI.important("Please run 'just generate' to apply the updated provisioning profiles.")
  end

  desc "Sync development certificates and profiles for local development"
  lane :sync_dev_certificates do
    # Sync development certificates (readonly for team members)
    # app_identifier and team_id are inherited from Matchfile and Appfile
    match(
      type: "development",
      readonly: true
    )

    # Update code signing for SNUTT Dev (with .dev suffix)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTT"],
      build_configurations: "Dev",
      bundle_identifier: BUNDLE_ID_DEV,
      code_sign_identity: "iPhone Developer",
      profile_name: ENV["sigh_#{BUNDLE_ID_DEV}_development_profile-name"]
    )

    # Update code signing for SNUTT Dev Widget
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTTWidgetExtension"],
      build_configurations: "Dev",
      bundle_identifier: BUNDLE_ID_DEV_WIDGET,
      code_sign_identity: "iPhone Developer",
      profile_name: ENV["sigh_#{BUNDLE_ID_DEV_WIDGET}_development_profile-name"]
    )

    # Update code signing for SNUTT Prod (without .dev suffix)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTT"],
      build_configurations: "Prod",
      bundle_identifier: BUNDLE_ID_PROD,
      code_sign_identity: "iPhone Developer",
      profile_name: ENV["sigh_#{BUNDLE_ID_PROD}_development_profile-name"]
    )

    # Update code signing for SNUTT Prod Widget
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ_PATH,
      targets: ["SNUTTWidgetExtension"],
      build_configurations: "Prod",
      bundle_identifier: BUNDLE_ID_PROD_WIDGET,
      code_sign_identity: "iPhone Developer",
      profile_name: ENV["sigh_#{BUNDLE_ID_PROD_WIDGET}_development_profile-name"]
    )

    UI.success("âœ… Development certificates synced and code signing configured!")
  end

  desc "Sync certificates and provisioning profiles using Match"
  lane :sync_certificates do |options|
    setup_ci if ENV["CI"]

    match(
      type: "appstore",
      app_identifier: options[:app_identifier],
      readonly: is_ci
    )
  end

  desc "Deploy to TestFlight or App Store"
  lane :deploy do |options|
    scheme = options[:scheme]
    configuration = options[:configuration]
    app_identifier = options[:app_identifier]
    deploy_target = options[:deploy_target] # "testflight" or "appstore"
    add_badge = options[:add_badge] || false
    git_tag_name = ENV["GIT_TAG_NAME"] || last_git_tag

    # Get marketing version from xcconfig
    marketing_version = get_xcconfig_value(
      path: "XCConfigs/Base.xcconfig",
      name: "MARKETING_VERSION"
    )

    begin
      # Get API key for App Store Connect
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_KEY_ISSUER"],
        key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"]
      )

      # Sync certificates
      sync_certificates(app_identifier: app_identifier)

      # Get the latest build number from App Store Connect
      latest_build_number = latest_testflight_build_number(
        app_identifier: app_identifier,
        api_key: api_key
      )

      new_build_number = latest_build_number + 1
      UI.message("Latest build number: #{latest_build_number}")
      UI.message("New build number: #{new_build_number}")

      # Update build number in Base.xcconfig
      set_xcconfig_value(
        path: "XCConfigs/Base.xcconfig",
        name: "CURRENT_PROJECT_VERSION",
        value: new_build_number.to_s
      )

      # Generate Xcode project using Tuist
      UI.message("Generating Xcode project with Tuist...")
      sh("cd ../.. && tuist generate --no-open")

      # Add beta badge if requested (for dev builds)
      if add_badge
        UI.message("Adding beta badge to app icon...")
        add_badge(dark: true)
      end

      # Build the app
      build_app(
        scheme: scheme,
        configuration: configuration,
        export_method: "app-store",
        export_options: {
          provisioningProfiles: {
            app_identifier => "match AppStore #{app_identifier}",
            "#{app_identifier}.widget" => "match AppStore #{app_identifier}.widget"
          }
        }
      )

      # Upload to App Store Connect
      if deploy_target == "appstore"
        # Get release notes from environment (extracted by GitHub Actions)
        release_notes = ENV["RELEASE_NOTES"]

        # Validate release notes are not empty
        if release_notes.nil? || release_notes.strip.empty?
          UI.user_error!("Release notes are empty. Please add release notes to the GitHub Release before deploying to App Store.")
        end

        upload_to_app_store(
          api_key: api_key,
          skip_screenshots: true,
          skip_metadata: true,
          precheck_include_in_app_purchases: false,
          submit_for_review: true,
          release_notes: {
            'default' => release_notes,
            'ko' => release_notes
          },
          submission_information: {
            add_id_info_uses_idfa: false,
            export_compliance_uses_encryption: false
          }
        )
      else
        upload_to_testflight(
          api_key: api_key,
          skip_waiting_for_build_processing: true
        )
      end

      # Notify success
      UI.success("Successfully deployed #{scheme} (build #{new_build_number}) to #{deploy_target}!")

      # Send success notification to Slack
      send_slack_notification(
        success: true,
        deploy_target: deploy_target,
        configuration: configuration,
        marketing_version: marketing_version,
        build_number: new_build_number,
        git_tag_name: git_tag_name
      )
    rescue => exception
      # Send failure notification to Slack
      send_slack_notification(
        success: false,
        deploy_target: deploy_target,
        configuration: configuration,
        marketing_version: marketing_version,
        build_number: nil,
        git_tag_name: git_tag_name,
        error_message: exception.message
      )
      raise exception
    end
  end

  desc "Deploy Dev build to TestFlight"
  lane :deploy_dev_testflight do
    deploy(
      scheme: "SNUTT Dev",
      configuration: "Dev",
      app_identifier: BUNDLE_ID_DEV,
      deploy_target: "testflight",
      add_badge: true
    )
  end

  desc "Deploy Prod build to TestFlight"
  lane :deploy_prod_testflight do
    deploy(
      scheme: "SNUTT Prod",
      configuration: "Prod",
      app_identifier: BUNDLE_ID_PROD,
      deploy_target: "testflight"
    )
  end

  desc "Deploy Prod build to App Store"
  lane :deploy_prod_appstore do
    deploy(
      scheme: "SNUTT Prod",
      configuration: "Prod",
      app_identifier: BUNDLE_ID_PROD,
      deploy_target: "appstore"
    )
  end

  error do |lane, exception, options|
    UI.error("Error in lane #{lane}: #{exception.message}")
  end

  # Helper function to send Slack notifications
  def send_slack_notification(success:, deploy_target:, configuration:, marketing_version:, build_number:, git_tag_name:, error_message: nil)
    slack_webhook = ENV["SLACK_WEBHOOK"]
    return if slack_webhook.nil? || slack_webhook.empty?

    message = success ?
      "iOS app successfully uploaded to #{deploy_target.capitalize} ðŸŽ‰" :
      "iOS deployment to #{deploy_target.capitalize} failed ðŸ˜¢"

    fields = [
      {
        title: "Target",
        value: deploy_target.capitalize,
        short: true
      },
      {
        title: "Environment",
        value: configuration,
        short: true
      },
      {
        title: "Version",
        value: marketing_version,
        short: true
      }
    ]

    if success
      fields << {
        title: "Build Number",
        value: build_number.to_s,
        short: true
      }
    end

    fields << {
      title: "Tag",
      value: git_tag_name,
      short: false
    }

    if error_message
      fields << {
        title: "Error",
        value: error_message,
        short: false
      }
    end

    slack(
      message: message,
      channel: "#team-snutt-deploy",
      slack_url: slack_webhook,
      success: success,
      attachment_properties: {
        fields: fields
      },
      default_payloads: [:git_branch, :git_author, :last_git_commit_hash, :last_git_commit]
    )
  end
end
